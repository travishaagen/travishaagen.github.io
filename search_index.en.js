window.searchIndex = [{"url":"https://travishaagen.github.io/posts/","title":"Posts","body":""},{"url":"https://travishaagen.github.io/posts/static-exceptions-for-flow-control/","title":"Static Exceptions for Flow Control","body":"Static Exceptions, when used for flow control, can dramatically reduce garbage generation and latency in Java and Kotlin\napplications.\nTL;DR\nTo create high performance exceptions for flow control in the JVM, simply extend the following StaticException class.\nThen store the Exception instance in a static final field and throw it as needed. They're fast, because the call\nstack doesn't need to be traversed and since we're creating reusable objects, there's less for the garbage collector\nto do.\nJava:\n\nKotlin:\n\nExample Use Case\nIn a web application, conditions that trigger HTTP error responses can happen anywhere in the call chain. For example,\nthe client's bearer token has expired, so we return 401 Unauthorized. A request is malformed, so validation\nlogic returns 400 Bad Request. Likewise, deeper in the call chain, an asynchronous API call times out, so we return\n503 Service Unavailable. None of these error conditions are particularly unexpected, and aside from the timeout,\nmay not even warrant logging.\nFor JVM applications it can be convenient to throw an exception that signifies \"respond with an error\". When the\nexception is caught, we build the appropriate HTTP response. An example response exception might be,\n\nWhich could be caught in our web controller logic, or a framework mechanism such as a Spring\n@ExceptionHandler,\nwhere the appropriate HTTP response status header and payload body would be constructed,\n\nDiscussion\nWe're using exceptions for flow control. Unfortunately, from a performance perspective, exceptions are expensive.\nThe bulk of the cost comes from Throwable.fillInStackTrace() which traverses the\ncall stack, and is exacerbated by massively long call stacks created by\nlibraries and frameworks that we use to make life easier.\nFortunately, there is a solution. We can preinitialize exceptions and either generate the call stack once, or\nprovide an empty stack. I first learned about this technique from Norman Maurer's blog post\nentitled “The hidden performance costs of instantiating Throwables”.\nNorman is one of the creators of Netty which is an abstraction over Java's internal\nsockets and byte buffers. It's a technique that has been used sparingly in Netty itself.\nHowever, if you do it wrong, it can lead to problems. Let's look at this constructor for Throwable,\n\nIt's most essential that we set enableSuppression to false. Otherwise, our own code or magical side effects from\nlibraries could invoke the addSuppressed method, and potentially add objects to the suppressedExceptions\ncollection every time we throw the reusable exception. The collection would grow infinitely.\n\nThis happened to me (:faceplant:). It turns out that Project Reactor invokes\naddSuppressed in a class called\nFluxOnAssembly\nevery time an Exception passes through.\nBenchmarks\nNorman included some Java Microbenchmark Harness (JMH) results in the\nbeforementioned blog post.\nI also ran across\n“Why Consuming Stack Traces is Noticeably Slower in Java 11 Compared to Java 8: JMH Benchmark Results.”\nIt makes some interesting points and I didn't realize that Java 11 introduced a change that was meant to improve\naverage performance by lazily traversing the call stack for logging. Because of this lazy traversal, I included\nsome additional *AndGetStacktrace JMH benchmarks below.\n\nTo summarize,\n\nThrowing and catching a reusable StaticException reached 1,799,330,563 operations/second\nReusable StaticException followed by a call to e.getStackTrace() was 105,525,289 operations/second\nThrowing a new RuntimeException every time was 1,529,637 operations/second\nAnd RuntimeException with e.getStackTrace() was 328,081 operations/second\n\nComparing the flow control static use case #1 with new #3 shows 1000x better performance for\nStaticException.\nBoth the static and new cases are seriously hampered whenever you choose to log the stacktrace.\nThe result for staticExceptionAndGetStacktrace is surprising, because the only additional operation is calling\nclone()\non our empty StackTraceElement[] array. Long call stacks were not simulated with the benchmarks either.\nAbove benchmark code available at\nhttps://github.com/travishaagen/blog-static-exceptions-for-flow-control\nFinal Thoughts\nThrowing exceptions has a cost in the JVM. For optimal performance, exceptions should be thrown sparingly.\nWhen a failure condition is not unexpected, your application's latency and throughput can benefit\nfrom static exceptions.\nReferences\n\nMaurer, N. (2013, November 9). The hidden performance costs of instantiating Throwables. The Thoughts of Norman\nMaurer. http://normanmaurer.me/blog/2013/11/09/The-hidden-performance-costs-of-instantiating-Throwables/\nWhy Consuming Stack Traces is Noticeably Slower in Java 11 Compared to Java 8: JMH Benchmark Results.\n(2025, November 26). javaspring.net.\nhttps://www.javaspring.net/blog/consuming-stack-traces-noticeably-slower-in-java-11-than-java-8/\n\n"},{"url":"https://travishaagen.github.io/","title":"Home","body":"About\nHey, I'm Travis Haagen. I've been a software engineer for a while.\nReach me on LinkedIn or BlueSky.\n"}]